<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pshocker.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Shocker">
<meta property="og:url" content="https://pshocker.github.io/page/2/index.html">
<meta property="og:site_name" content="Shocker">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Shocker">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pshocker.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Shocker</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Shocker</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/17/Android%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/Android%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">Android读写内存效率比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-17 14:15:22 / 修改时间：18:39:01" itemprop="dateCreated datePublished" datetime="2022-04-17T14:15:22+08:00">2022-04-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>众所周知,安卓平台读写内存的方式有</p>
<p>1.read write &#x2F;proc&#x2F;xx&#x2F;mem 文件<br>2.ptrace<br>3.syscall<br>4.注入读写(Magisk注入)</p>
<p>那么他们谁的读写效率更高呢?</p>
<p>测试方法很简单.读写100000次,记录时间差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime(CLOCK_MONOTONIC, &amp;old);</span><br><span class="line">for (size_t i = 0; i &lt; 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">..............</span><br><span class="line">..............</span><br><span class="line">&#125;</span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &amp;now);</span><br><span class="line">cout &lt;&lt; &quot;time passed is: &quot; &lt;&lt; (now.tv_sec - old.tv_sec) * 1000 + (now.tv_nsec - old.tv_nsec) / 1000000 &lt;&lt; &quot;ms&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>以下是分别测试读写100000次所需要的时间</p>
<table border="0" cellpadding="0" cellspacing="0" width="646" style="border-collapse:
 collapse;table-layout:fixed;width:485pt">
 <col width="64" style="width:48pt">
 <col width="146" style="mso-width-source:userset;mso-width-alt:5176;width:109pt">
 <col width="156" style="mso-width-source:userset;mso-width-alt:5546;width:117pt">
 <col width="150" style="mso-width-source:userset;mso-width-alt:5347;width:113pt">
 <col width="130" style="mso-width-source:userset;mso-width-alt:4636;width:98pt">
 <tr height="18" style="height:13.8pt">
  <td height="18" width="64" style="height:13.8pt;width:48pt"></td>
  <td width="146" style="width:109pt">mem</td>
  <td width="156" style="width:117pt">ptrace</td>
  <td width="150" style="width:113pt">syscall</td>
  <td width="130" style="width:98pt">注入读写</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td height="18" style="height:13.8pt">读</td>
  <td>155ms</td>
  <td>2983ms</td>
  <td>101ms</td>
  <td>0.000069ms</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td height="18" style="height:13.8pt">写</td>
  <td>416ms</td>
  <td>2940ms</td>
  <td>88ms</td>
  <td>0.000243ms</td>
 </tr>
</table>

<p>可以看出,效率最快的是注入读写,比syscall和读mem快了近1000000倍.</p>
<p>而ptrace效率低很大程度上因为ptrace的PTRACE_ATTACH和PTRACE_DETACH消耗了大量时间.</p>
<p>读写效率:<br>注入读写 &gt;&gt; syscall &gt; mem &gt; ptrace</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/16/Hook-surfaceflinger%E8%BF%9B%E7%A8%8B%E7%BB%99surface%E5%BC%80%E5%90%8E%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/16/Hook-surfaceflinger%E8%BF%9B%E7%A8%8B%E7%BB%99surface%E5%BC%80%E5%90%8E%E9%97%A8/" class="post-title-link" itemprop="url">Hook surfaceflinger进程给surface开后门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 14:21:03" itemprop="dateCreated datePublished" datetime="2022-04-16T14:21:03+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-25 11:35:04" itemprop="dateModified" datetime="2022-05-25T11:35:04+08:00">2022-05-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于可执行文件创建的surface来说.它的uid和pid都为0.</p>
<p>对于app内部创建的surface来说.它的uid和pid都不为0.</p>
<p>见<a href="https://pshocker.github.io/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/">Magisk注入app并嵌入imgui(三)</a></p>
<p>我们只需要找到app创建的surface,并把它的pid和uid改成0,就可以实现可执行文件的效果.</p>
<p>1.注入surfaceflinger进程<br>参考:<a target="_blank" rel="noopener" href="https://github.com/PShocker/AndroidPtraceInject">AndroidPtraceInject</a><br>参考:<a target="_blank" rel="noopener" href="https://github.com/SsageParuders/AndroidPtraceInject">AndroidPtraceInject</a></p>
<p>2.Dobby hook createSurface</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int hook_createSurface()</span><br><span class="line">&#123;</span><br><span class="line">    LOGD(&quot;hook_createSurface start\n&quot;);</span><br><span class="line">    void *sym = DobbySymbolResolver(NULL, &quot;_ZN7android6Client13createSurfaceERKNS_7String8EjjijRKNS_2spINS_7IBinderEEENS_13LayerMetadataEPS6_PNS4_INS_22IGraphicBufferProducerEEEPiPj&quot;);</span><br><span class="line">    if (NULL != sym)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGD(&quot;_ZN7android6Client13createSurfaceERKNS_7String8EjjijRKNS_2spINS_7IBinderEEENS_13LayerMetadataEPS6_PNS4_INS_22IGraphicBufferProducerEEEPiPj:%llx&quot;, (unsigned long long)sym);</span><br><span class="line">        DobbyHook(sym, (void *)new_createSurface, (void **)&amp;ori_createSurface);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(&quot;hook_createSurface finish\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.从surface的name拿到想要hook的surface的pid和uid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int64_t new_createSurface(void *thiz, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12)</span><br><span class="line">&#123;</span><br><span class="line">    // LOGD(&quot;new_createSurface&quot;);</span><br><span class="line">    if (NULL == ori_createSurface)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;failed to get original new_createSurface&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(&quot;str:%llx&quot;, *(unsigned long long *)*(unsigned long long *)a2);</span><br><span class="line"></span><br><span class="line">    if (*(unsigned long long *)*(unsigned long long *)a2 == 0x72656b636f6853) //这里根据surface的名字来判断是否是要Hook的surface.strcmp()会闪退,只能用字符串的16进制来比较.</span><br><span class="line">    &#123;</span><br><span class="line">        LOGD(&quot;getCallingPid:%d&quot;, getCallingPid());</span><br><span class="line">        LOGD(&quot;getCallingUid:%d&quot;, getCallingUid());</span><br><span class="line">        Hook_Pid = getCallingPid(); //这里拿到Pid</span><br><span class="line">        Hook_Uid = getCallingUid(); //Uid</span><br><span class="line">    &#125;</span><br><span class="line">    return ori_createSurface(thiz, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Dobby hook getCallingPid和getCallingUid<br>Hook代码省略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int64_t new_getCallingPid(void *thiz)</span><br><span class="line">&#123;</span><br><span class="line">    // LOGD(&quot;new_getCallingPid&quot;);</span><br><span class="line">    if (NULL == ori_getCallingPid)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;failed to get original new_getCallingPid&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int Pid = ori_getCallingPid(thiz);</span><br><span class="line">    if (Pid == Hook_Pid)</span><br><span class="line">    &#123;</span><br><span class="line">        Hook_Uid = getCallingUid(); //更新Uid</span><br><span class="line">        return 0; //如果是我们创建的surface,就返回0</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return Pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int64_t new_getCallingUid(void *thiz)</span><br><span class="line">&#123;</span><br><span class="line">    // LOGD(&quot;new_getCallingUid&quot;);</span><br><span class="line">    if (NULL == ori_getCallingUid)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;failed to get original new_getCallingUid&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int Uid = ori_getCallingUid(thiz);</span><br><span class="line">    if (Uid == Hook_Uid)</span><br><span class="line">    &#123;</span><br><span class="line">        // LOGE(&quot;Hook Uid&quot;);</span><br><span class="line">        return 0; // 如果是我们创建的surface,就返回0</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return Uid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getCallingPid()和getCallingUid()可以在aosp环境里封装一个.a的静态库<br>编译的时候链接就行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int getCallingPid()</span><br><span class="line">&#123;</span><br><span class="line">    IPCThreadState *ipc = IPCThreadState::self();</span><br><span class="line">    return ipc-&gt;getCallingPid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getCallingUid()</span><br><span class="line">&#123;</span><br><span class="line">    IPCThreadState *ipc = IPCThreadState::self();</span><br><span class="line">    return ipc-&gt;getCallingUid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/" class="post-title-link" itemprop="url">Magisk注入app并嵌入imgui(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-16 11:26:19 / 修改时间：14:57:02" itemprop="dateCreated datePublished" datetime="2022-04-16T11:26:19+08:00">2022-04-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在<a href="https://pshocker.github.io/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/">Magisk注入app并嵌入imgui(二)</a>里成功创建了surface,但是imgui的画面并没有显示出来,<br><img src="/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/why.jpg"></p>
<p>看看SurfaceFlinger的信息.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/layers.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Offscreen Layers:</span><br><span class="line">Layer Surface(name=cac9055 InputMethod)/@0x5406b5b - animation-leash of insets_animation#0 (EffectLayer) callingPid:3013 callingUid:1000 ownerUid:1000</span><br><span class="line">Layer Surface(name=50f3462 com.tencent.mf.uam/com.epicgames.ue4.GameActivity)/@0x5e8236 - animation-leash of starting_reveal#0 (EffectLayer) callingPid:3013 callingUid:1000 ownerUid:1000</span><br><span class="line">Layer Surface(name=Task=1)/@0xca72fe0 - animation-leash of app_transition#0 (EffectLayer) callingPid:3013 callingUid:1000 ownerUid:1000</span><br><span class="line">Layer Surface(name=Task=185)/@0xc4029e3 - animation-leash of app_transition#0 (EffectLayer) callingPid:3013 callingUid:1000 ownerUid:1000</span><br><span class="line">Layer Shocker#0 (BufferStateLayer) callingPid:8669 callingUid:10219 ownerUid:10219</span><br><span class="line">Layer bbq-wrapper#1 (BufferStateLayer) callingPid:8669 callingUid:10219 ownerUid:10219</span><br></pre></td></tr></table></figure>
<p>唉,我的Layer怎么在Offscreen里?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Layer Shocker#0 (BufferStateLayer) callingPid:8669 callingUid:10219 ownerUid:10219</span><br></pre></td></tr></table></figure>

<p>打开imgui可执行文件的版本.<br>看看有什么区别.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ BufferStateLayer (ImGuiLink#0  screenFlags = 0  miuiVkWidgetTransparent = 0) uid=0</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(  -1,  -1), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isTrustedOverlay=0, isOpaque=0, invalidate=0, dataspace=Default, defaultPixelFormat=Unknown/None, backgroundBlurRadius=0, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=none</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;, cornerRadiusCrop=[0.00, 0.00, 0.00, 0.00],  shadowRadius=0.000,</span><br><span class="line">+ BufferStateLayer (bbq-wrapper#0  screenFlags = 0  miuiVkWidgetTransparent = 0) uid=0</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=1)</span><br><span class="line">    [  0,   0, 1440, 3200]</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(1440,3200), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isTrustedOverlay=0, isOpaque=0, invalidate=0, dataspace=Default, defaultPixelFormat=RGBA_8888, backgroundBlurRadius=0, color=(0.000,0.000,0.000,1.000), flags=0x00000100, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=ImGuiLink#0  screenFlags = 0  miuiVkWidgetTransparent = 0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[1440x3200:1472,RGBA_8888], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;dequeueTime:514178138135&#125;, cornerRadiusCrop=[0.00, 0.00, 0.00, 0.00],  shadowRadius=0.000,</span><br></pre></td></tr></table></figure>
<p>唉,发现可执行文件的uid&#x3D;0而,app创建的surface的uid不为0.</p>
<p>去源码看看.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4353      bool addToRoot = callingThreadHasUnscopedSurfaceFlingerAccess();</span><br><span class="line">4354      result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer, addToRoot,</span><br><span class="line">4355                              outTransformHint);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://aospxref.com/android-12.0.0_r3/s?refs=createLayer&amp;project=frameworks">http://aospxref.com/android-12.0.0_r3/s?refs=createLayer&amp;project=frameworks</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3888  bool SurfaceFlinger::callingThreadHasUnscopedSurfaceFlingerAccess(bool usePermissionCache) &#123;</span><br><span class="line">3889      IPCThreadState* ipc = IPCThreadState::self();</span><br><span class="line">3890      const int pid = ipc-&gt;getCallingPid();</span><br><span class="line">3891      const int uid = ipc-&gt;getCallingUid();</span><br><span class="line">3892      if ((uid != AID_GRAPHICS &amp;&amp; uid != AID_SYSTEM) &amp;&amp;</span><br><span class="line">3893          (usePermissionCache ? !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)</span><br><span class="line">3894                              : !checkPermission(sAccessSurfaceFlinger, pid, uid))) &#123;</span><br><span class="line">3895          return false;</span><br><span class="line">3896      &#125;</span><br><span class="line">3897      return true;</span><br><span class="line">3898  &#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://aospxref.com/android-12.0.0_r3/s?refs=callingThreadHasUnscopedSurfaceFlingerAccess&amp;project=frameworks">http://aospxref.com/android-12.0.0_r3/s?refs=callingThreadHasUnscopedSurfaceFlingerAccess&amp;project=frameworks</a></p>
<p>这里的pid,uid就是通过下面的函数获取的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3890      const int pid = ipc-&gt;getCallingPid();</span><br><span class="line">3891      const int uid = ipc-&gt;getCallingUid();</span><br></pre></td></tr></table></figure>

<p>对于可执行文件来说,pid和uid都是0.</p>
<p>那么有没有办法让我们创建的surface pid和uid同时为0呢?</p>
<p>当然有…<br><a href="https://pshocker.github.io/2022/04/16/Hook-surfaceflinger%E8%BF%9B%E7%A8%8B%E7%BB%99surface%E5%BC%80%E5%90%8E%E9%97%A8/">Hook surfaceflinger进程给surface开后门</a></p>
<p>最后做一个总结:<br>相比于外部imgui,hook eglswapbuffers来说,creteSurface基本上是最优解,它既不会涉及到跨进程读写内存,也不会卡游戏画面.<br>唯一美中不足的地方就是编译复杂,没法跨安卓版本使用.</p>
<p><img src="/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/dog.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/" class="post-title-link" itemprop="url">Magisk注入app并嵌入imgui(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-15 22:49:47" itemprop="dateCreated datePublished" datetime="2022-04-15T22:49:47+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-16 15:01:22" itemprop="dateModified" datetime="2022-04-16T15:01:22+08:00">2022-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我写过一篇文章介绍了<a href="https://pshocker.github.io/2022/03/21/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui/">Magisk注入app并嵌入imgui</a>.<br>其原理就是Hook app进程的eglSwapBuffers函数.在其中完成imgui的初始化的显示.</p>
<p>但我测试UE4游戏的时候发现,要么画面出不来,要么就闪退.<br>大概率是和引擎冲突了…<br>淦.<br><img src="/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/g.jpg"></p>
<p>没办法,那么就创建一个surface.<br>注意,createSurface等函数需要aosp环境.所以需要在<strong>aosp环境里编译zygisk模块.</strong></p>
<h2 id="环境和工具"><a href="#环境和工具" class="headerlink" title="环境和工具"></a>环境和工具</h2><p>1.Android 12环境(版本可根据自己真机版本选择,硬盘空间最好大于250G,不然拉取失败会出现很多问题)<br>2.wsl或虚拟机(wsl Ubuntu18.04)<br>3.安卓真机(小米12)</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="下载Android12-编译Android12"><a href="#下载Android12-编译Android12" class="headerlink" title="下载Android12,编译Android12."></a>下载Android12,编译Android12.</h3><p>这些网上有很多教学,值得一提的是,相比Android5,新版本编译的时候没有什么错误,基本上一次过.很爽.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/grackergao/article/details/120984766">Android 系统开发系列（1）：Android 12 源代码下载、编译和刷机</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68918808">死磕Android_AOSP编译过程</a></p>
<p><strong>注意:硬盘剩余空间一定要大于250g,硬盘剩余空间一定要大于250g,硬盘剩余空间一定要大于250g</strong><br><strong>否则失败了会很麻烦.</strong></p>
<p><img src="/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/kk.jpg"></p>
<h3 id="复制源文件到Android源码里"><a href="#复制源文件到Android源码里" class="headerlink" title="复制源文件到Android源码里"></a>复制源文件到Android源码里</h3><p>参考<a href="https://pshocker.github.io/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/">Android可执行文件imgui绘制</a>,区别就是编译成动态库(cc_library_shared),还要把zygisk头文件丢进去.<br><img src="/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/vscode.jpg"><br>文件结构如上图.</p>
<h3 id="过滤到包名-多线程创建imgui"><a href="#过滤到包名-多线程创建imgui" class="headerlink" title="过滤到包名,多线程创建imgui"></a>过滤到包名,多线程创建imgui</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void postAppSpecialize(const AppSpecializeArgs *args) override</span><br><span class="line">&#123;</span><br><span class="line">    // Use JNI to fetch our process name</span><br><span class="line">    const char *process = env-&gt;GetStringUTFChars(args-&gt;nice_name, nullptr);</span><br><span class="line">    if (init(process) == false)</span><br><span class="line">    &#123;</span><br><span class="line">        //没有找到游戏</span><br><span class="line">        api-&gt;setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(args-&gt;nice_name, process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool init(const char *process)</span><br><span class="line">&#123;</span><br><span class="line">    // LOGD(&quot;example: process=[%s]&quot;, process);</span><br><span class="line">    if (strcmp(hook_pkg_name, process) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_t ntid;</span><br><span class="line">        if (pthread_create(&amp;ntid, nullptr, startImGui, nullptr))</span><br><span class="line">        &#123;</span><br><span class="line">            LOGD(&quot;can&#x27;t create thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里startImGui的代码和<a href="https://pshocker.github.io/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/">Android可执行文件imgui绘制</a>代码一致.</p>
<h3 id="观察结果"><a href="#观察结果" class="headerlink" title="观察结果"></a>观察结果</h3><p>然后你会发现完全没有效果,但这并不意味着创建surface失败了,因为如果你打印surface的地址,会发现是有值的,如果你在tick打印日志,会发现日志会一直有输出.<br><img src="/2022/04/15/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%BA%8C/log.jpg"><br>为啥会这样呢?</p>
<p>见<a href="https://pshocker.github.io/2022/04/16/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui-%E4%B8%89/">Magisk注入app并嵌入imgui(三)</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">Android可执行文件imgui绘制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-15 21:49:47" itemprop="dateCreated datePublished" datetime="2022-04-15T21:49:47+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 11:23:04" itemprop="dateModified" datetime="2022-05-12T11:23:04+08:00">2022-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我在<a href="https://pshocker.github.io/2022/03/23/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C/">Android外部imgui绘制(二)</a>里说过</p>
<p><strong>在Android外部imgui绘制(一)里介绍了怎么实现一个外部imgui,其实还有一种方法,就是在aosp环境下编译一个可执行文件出来,有点类似于</strong><br><strong>可执行文件+skia绘制</strong><br><strong>但这个其实很麻烦,需要下载android源码(100多g),然后还要自己编译,最后还得修改代码.所以不太建议这么做.虽然效率可能确实会有提升.</strong></p>
<p>好吧,我来填坑了.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="下载Android12-编译Android12"><a href="#下载Android12-编译Android12" class="headerlink" title="下载Android12,编译Android12."></a>下载Android12,编译Android12.</h3><p>这些网上有很多教学,值得一提的是,相比Android5,新版本编译的时候没有什么错误,基本上一次过.很爽.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/grackergao/article/details/120984766">Android 系统开发系列（1）：Android 12 源代码下载、编译和刷机</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68918808">死磕Android_AOSP编译过程</a></p>
<p><strong>注意:硬盘剩余空间一定要大于250g,硬盘剩余空间一定要大于250g,硬盘剩余空间一定要大于250g</strong><br><strong>否则失败了会很麻烦.</strong></p>
<h3 id="复制源文件到Android源码里"><a href="#复制源文件到Android源码里" class="headerlink" title="复制源文件到Android源码里"></a>复制源文件到Android源码里</h3><p>把imgui的相关代码丢到external里.</p>
<p><img src="/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/vscode.jpg"><br>文件结构如上图.</p>
<h3 id="imgui"><a href="#imgui" class="headerlink" title="imgui"></a>imgui</h3><p>1.新建SurfaceComposerClient,并从SurfaceComposerClient中创建surface,这个SurfaceComposerClient其实是surfaceflinger进程的代理对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient();</span><br><span class="line">sp&lt;IBinder&gt; mDisplay = SurfaceComposerClient::getInternalDisplayToken();</span><br><span class="line"></span><br><span class="line">ui::DisplayMode mode;</span><br><span class="line">status_t result = SurfaceComposerClient::getActiveDisplayMode(mDisplay, &amp;mode);</span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; control = client-&gt;createSurface(</span><br><span class="line">        String8(&quot;Shocker&quot;),</span><br><span class="line">        mode.resolution.getWidth(),</span><br><span class="line">        mode.resolution.getHeight(),</span><br><span class="line">        PIXEL_FORMAT_RGBA_8888,</span><br><span class="line">        ISurfaceComposerClient::eFXSurfaceBufferState,</span><br><span class="line">        nullptr);</span><br></pre></td></tr></table></figure>
<p>这其实非常重要,对于imgui来说,它只需要绑定一个窗口(NativeWindow),就可以在上面绘制.</p>
<p>2.获取NativeWindow,绑定到imgui上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; mSurface = control-&gt;getSurface();</span><br><span class="line">sp&lt;ANativeWindow&gt; mANW = mSurface;</span><br><span class="line">ANativeWindow *g_EglNativeWindowType(mANW.get());</span><br><span class="line">LOGD(&quot;initSurface finish&quot;);</span><br><span class="line">LOGD(&quot;g_EglNativeWindowType:%llx&quot;, g_EglNativeWindowType);</span><br><span class="line"></span><br><span class="line">init(g_EglNativeWindowType);</span><br></pre></td></tr></table></figure>
<p>3.imgui初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void init(ANativeWindow *g_EglNativeWindowType)</span><br><span class="line">&#123;</span><br><span class="line">    if (g_Initialized)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    ANativeWindow_acquire(g_EglNativeWindowType);</span><br><span class="line">............................</span><br><span class="line">(把源码里的g_App-&gt;window全部替换成g_EglNativeWindowType,其余不变)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.imgui循环渲染</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    handleInputEvent(); //处理触摸事件,获取触摸可以参考我之前的文章.</span><br><span class="line">    tick(); //渲染画面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后一点"><a href="#最后一点" class="headerlink" title="最后一点"></a>最后一点</h2><p>安卓12要用Android.bp文件来编写编译文件,貌似之前的Android.mk可以用,但有bug.<br>附上我编译imgui用的Android.bp文件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;ImGuiTest&quot;,</span><br><span class="line">    srcs: [&quot;src/**/*.cpp&quot;],</span><br><span class="line"></span><br><span class="line">    local_include_dirs: [</span><br><span class="line">        &quot;src&quot;,</span><br><span class="line">        &quot;src/imgui&quot;,</span><br><span class="line">        &quot;src/backends&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    cppflags: [</span><br><span class="line">        &quot;-Wno-error&quot;,</span><br><span class="line">        &quot;-Wno-sign-conversion&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-Wno-sign-conversion&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libandroid&quot;,</span><br><span class="line">        &quot;libgui&quot;,</span><br><span class="line">        &quot;libEGL&quot;,</span><br><span class="line">        &quot;libGLESv2&quot;,</span><br><span class="line">        &quot;libbinder&quot;,</span><br><span class="line">        &quot;libui&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;libinput&quot;,</span><br><span class="line">        &quot;libinputflinger&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/15/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6imgui%E7%BB%98%E5%88%B6/imgui.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/" class="post-title-link" itemprop="url">Magisk注入Unity全自动Hook实战--神庙逃亡2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 21:20:28" itemprop="dateCreated datePublished" datetime="2022-04-04T21:20:28+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-05 10:50:05" itemprop="dateModified" datetime="2022-04-05T10:50:05+08:00">2022-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前的一篇文章<a href="https://pshocker.github.io/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/">Android外部imgui绘制(二)–补充
</a>提到了<a target="_blank" rel="noopener" href="https://0x.mk/?p=192">Unity全自动hook的实现</a>.那么就来实战一下.<br>游戏:<a target="_blank" rel="noopener" href="https://tp2.uu.cc/">神庙逃亡2</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>1.<a target="_blank" rel="noopener" href="https://github.com/Perfare/Il2CppDumper">Il2CppDumper</a><br>2.ida7.5<br>3.ndk等编译环境</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="Il2CppDumper解压出dump-cs等函数信息"><a href="#Il2CppDumper解压出dump-cs等函数信息" class="headerlink" title="Il2CppDumper解压出dump.cs等函数信息"></a>Il2CppDumper解压出dump.cs等函数信息</h3><p>下载<a target="_blank" rel="noopener" href="https://github.com/Perfare/Il2CppDumper/releases/">Il2CppDumper解压出dump</a><br>把apk里的global-metadata.dat </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\assets\bin\Data\Managed\Metadata\global-metadata.dat</span><br></pre></td></tr></table></figure>
<p>和libil2cpp.so </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\lib\armeabi-v7a\libil2cpp.so</span><br></pre></td></tr></table></figure>
<p>提取出来,新建文件夹out,命令行执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Il2CppDumper.exe libil2cpp.so global-metadata.dat out</span><br></pre></td></tr></table></figure>
<p>之后解压后的头文件会在out文件夹里<br><img src="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/out.png" alt="out"></p>
<h3 id="dump-cs里搜索关键点"><a href="#dump-cs里搜索关键点" class="headerlink" title="dump.cs里搜索关键点"></a>dump.cs里搜索关键点</h3><p>打开dump.cs,搜索kill.顺便一提,对于没有加密的u3的游戏来说,关键点基本上就是money,coin,kill,death,start等.我的目标是实现人物无敌,所以才选择kill.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RVA: 0x7A7FE0 Offset: 0x7A7FE0 VA: 0x7A7FE0</span><br><span class="line">public void Kill(DeathTypes deathType, float shakeCamMagnitude = 0, bool killBySelf = False) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>得到它的RVA是<strong>0x7A7FE0</strong>.</p>
<h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p>ida打开libil2cpp.so,Alt+F7执行脚本ida_py3.py,选择out文件夹里的script.json,导入所有函数符号到ida.<br>跳转到地址0x7A7FE0,在函数头按X查看其交叉引用.<br><img src="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/ida0.png" alt="ida0"><br><img src="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/jcyy.png" alt="jcyy"><br>点击,因为Stumble有绊倒的意思.分析它大概是一个判断人物失误的函数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRRunnerPawn$$Stumble+1548</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/ida.png" alt="ida"><br>唉,看到 Invincible 了,英语不好的我查了下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invincible 无敌的; 不可战胜的; 不能改变的;</span><br></pre></td></tr></table></figure>
<p>好家伙,这不就是我们要的判断无敌的函数吗?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRRunnerPawn__IsInvincible(a1)</span><br></pre></td></tr></table></figure>
<p>干就完事了.</p>
<h3 id="自动Hook"><a href="#自动Hook" class="headerlink" title="自动Hook"></a>自动Hook</h3><p>dump.cs搜索 IsInvincible</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RVA: 0x795050 Offset: 0x795050 VA: 0x795050</span><br><span class="line">public bool IsInvincible() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>拿到地址后可以去ida修改硬编码,直接返回true.但是这样不够自动化.万一版本更新偏移变了咋办?</p>
<p>还记得一开头的<a target="_blank" rel="noopener" href="https://0x.mk/?p=192">Unity全自动hook的实现</a>吗?<br><a target="_blank" rel="noopener" href="https://github.com/kotori2/riru_unity_example">https://github.com/kotori2/riru_unity_example</a>.</p>
<p>我们就来全自动hook一次.-_-</p>
<p>大佬已经帮我们写好框架了.只需要填就行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Il2CppClass* clazz = il2cpp_class_from_name(image, &quot;&quot;, &quot;TRRunnerPawn&quot;);</span><br><span class="line">hook_each((unsigned long)il2cpp_class_get_method_from_name(clazz, &quot;IsInvincible&quot;, 0)-&gt;methodPointer, (void *)hook_invincible, (void **)&amp;backup_invincible);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int hook_invincible(int a1)</span><br><span class="line">&#123;</span><br><span class="line">    if (backup_invincible == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;backup DOES NOT EXIST&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // LOGD(&quot;hook&quot;);</span><br><span class="line">    int r = backup_invincible(a1);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<br><strong>il2cpp_class_get_method_from_name的第3个参数是该方法的参数个数(dump.cs里看到的参数个数,不是ida),填错就直接闪退.</strong></p>
<p><img src="/2022/04/04/Magisk%E6%B3%A8%E5%85%A5Unity%E5%85%A8%E8%87%AA%E5%8A%A8Hook%E5%AE%9E%E6%88%98-%E7%A5%9E%E5%BA%99%E9%80%83%E4%BA%A12/smtw.gif" alt="smtw"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/02/Android-Hook-native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/Android-Hook-native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5/" class="post-title-link" itemprop="url">Android Hook native层获取系统输入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-02 21:51:03" itemprop="dateCreated datePublished" datetime="2022-04-02T21:51:03+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 13:12:41" itemprop="dateModified" datetime="2022-05-10T13:12:41+08:00">2022-05-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章<a href="https://pshocker.github.io/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/">Android外部imgui绘制(二)–补充</a>补充说明了ue4游戏下触摸输入的获取方法.本篇介绍一种更为通用的获取系统输入的方法.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在Android系统中获取系统输入的原理是读取”&#x2F;dev&#x2F;input&#x2F;event”下的文件,监听是否有系统输入.然后将不同的输入进行加工,然后分发.<br>在安卓系统中输入事件被分成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KeyEvent(键盘输入)</span><br><span class="line">MotionEvent(触摸输入)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>参考<br><a target="_blank" rel="noopener" href="http://aospxref.com/android-12.0.0_r3/xref/frameworks/native/libs/input/Input.cpp">&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;input&#x2F;Input.cpp</a></p>
<p>每一种Event在分发之前都会经过初始化的流程,以触摸事件为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1345  void InputConsumer::initializeMotionEvent(MotionEvent* event, const InputMessage* msg) &#123;</span><br><span class="line">1346      uint32_t pointerCount = msg-&gt;body.motion.pointerCount;</span><br><span class="line">1347      PointerProperties pointerProperties[pointerCount];</span><br><span class="line">1348      PointerCoords pointerCoords[pointerCount];</span><br><span class="line">1349      for (uint32_t i = 0; i &lt; pointerCount; i++) &#123;</span><br><span class="line">1350          pointerProperties[i].copyFrom(msg-&gt;body.motion.pointers[i].properties);</span><br><span class="line">1351          pointerCoords[i].copyFrom(msg-&gt;body.motion.pointers[i].coords);</span><br><span class="line">1352      &#125;</span><br><span class="line">1353  </span><br><span class="line">1354      ui::Transform transform;</span><br><span class="line">1355      transform.set(&#123;msg-&gt;body.motion.dsdx, msg-&gt;body.motion.dtdx, msg-&gt;body.motion.tx,</span><br><span class="line">1356                     msg-&gt;body.motion.dtdy, msg-&gt;body.motion.dsdy, msg-&gt;body.motion.ty, 0, 0, 1&#125;);</span><br><span class="line">1357      event-&gt;initialize(msg-&gt;body.motion.eventId, msg-&gt;body.motion.deviceId, msg-&gt;body.motion.source,</span><br><span class="line">1358                        msg-&gt;body.motion.displayId, msg-&gt;body.motion.hmac, msg-&gt;body.motion.action,</span><br><span class="line">1359                        msg-&gt;body.motion.actionButton, msg-&gt;body.motion.flags,</span><br><span class="line">1360                        msg-&gt;body.motion.edgeFlags, msg-&gt;body.motion.metaState,</span><br><span class="line">1361                        msg-&gt;body.motion.buttonState, msg-&gt;body.motion.classification, transform,</span><br><span class="line">1362                        msg-&gt;body.motion.xPrecision, msg-&gt;body.motion.yPrecision,</span><br><span class="line">1363                        msg-&gt;body.motion.xCursorPosition, msg-&gt;body.motion.yCursorPosition,</span><br><span class="line">1364                        msg-&gt;body.motion.displayWidth, msg-&gt;body.motion.displayHeight,</span><br><span class="line">1365                        msg-&gt;body.motion.downTime, msg-&gt;body.motion.eventTime, pointerCount,</span><br><span class="line">1366                        pointerProperties, pointerCoords);</span><br><span class="line">1367  &#125;</span><br></pre></td></tr></table></figure>
<p>注意到,event-&gt;initialize就是初始化一个MotionEvent.<br><strong>而这个函数(InputConsumer::initializeMotionEvent)就是需要Hook的函数.</strong><br>参考<br><a target="_blank" rel="noopener" href="http://aospxref.com/android-12.0.0_r3/xref/frameworks/native/libs/input/InputTransport.cpp#initializeMotionEvent">&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;input&#x2F;InputTransport.cpp</a></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>随便观察一个app进程的maps,过滤得到libinput.so的路径.</p>
<p><img src="/2022/04/02/Android-Hook-native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5/libinput.png" alt="libinput"></p>
<p>这个libinput.so就包含上面InputConsumer::initializeMotionEvent的代码.</p>
<p>拉到电脑上,ida打开.</p>
<p><img src="/2022/04/02/Android-Hook-native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5/ida.png" alt="ida"><br>得到它的导出函数符号是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ZN7android13InputConsumer21initializeMotionEventEPNS_11MotionEventEPKNS_12InputMessageE</span><br></pre></td></tr></table></figure>

<p>用Dobby进行hook</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void hook_input()</span><br><span class="line">&#123;</span><br><span class="line">    void *sym_input = DobbySymbolResolver(NULL, &quot;_ZN7android13InputConsumer21initializeMotionEventEPNS_11MotionEventEPKNS_12InputMessageE&quot;);</span><br><span class="line">    if (NULL != sym_input)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGD(&quot;_ZN7android13InputConsumer21initializeMotionEventEPNS_11MotionEventEPKNS_12InputMessageE:%llx&quot;, (unsigned long long)sym_input);</span><br><span class="line">        DobbyHook(sym_input, (void *)new_input, (void **)&amp;ori_input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在new_input就可以得到系统输入了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void new_input(void *thiz, void *a2, void *a3)</span><br><span class="line">&#123;</span><br><span class="line">    if (NULL == ori_input)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGD(&quot;failed to get original input&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ori_input(thiz, a2, a3);</span><br><span class="line">    // LOGD(&quot;new_input&quot;);</span><br><span class="line">    LOGD(&quot;action:%d&quot;, AMotionEvent_getAction((AInputEvent *)thiz));</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/02/Android-Hook-native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5/log.png" alt="log"></p>
<p><strong>如果出现崩溃等bug,请检查是否是DobbySymbolResolver的问题,请指定第一个参数为libinput.so的路径</strong><br><strong>例如:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *sym_input = DobbySymbolResolver(&quot;system/lib/libinput.so&quot;,&quot;_ZN7android13InputConsumer21initializeMotionEventEPNS_11MotionEventEPKNS_12InputMessageE&quot;);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">Android外部imgui绘制(二)--补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-01 16:30:43 / 修改时间：17:12:22" itemprop="dateCreated datePublished" datetime="2022-04-01T16:30:43+08:00">2022-04-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前几天看到评论区有个小伙伴问我,ue4游戏怎么寻找android_app和获取系统输入.<br>我在这说一下.</p>
<h1 id="获取android-app"><a href="#获取android-app" class="headerlink" title="获取android_app"></a>获取android_app</h1><h2 id="基址偏移法"><a href="#基址偏移法" class="headerlink" title="基址偏移法"></a>基址偏移法</h2><p>首先,需要找到libUE4.so的android_main函数.<br><img src="/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/android_main.png" alt="android_main"><br>ida进入android_main函数后按F5,<br><img src="/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/ida_f5.png" alt="ida_f5"><br>可以发现有一个全局变量保存了这个android_app变量.<br>那么它的地址就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libUE4.so(基址)+A36E1D0</span><br></pre></td></tr></table></figure>

<h2 id="注入Hook法-Magisk注入app并嵌入imgui"><a href="#注入Hook法-Magisk注入app并嵌入imgui" class="headerlink" title="注入Hook法 (Magisk注入app并嵌入imgui)"></a>注入Hook法 (Magisk注入app并嵌入imgui)</h2><p>参考了<a target="_blank" rel="noopener" href="https://0x.mk/?p=192">Unity全自动hook的实现</a><br>hook_each等代码可以在这里找到:<br><a target="_blank" rel="noopener" href="https://github.com/kotori2/riru_unity_example">https://github.com/kotori2/riru_unity_example</a>.</p>
<p>直接Hook libUE4.so的android_main函数拿到android_app变量.<br>1.Hook dl_open.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *loader_dlopen = DobbySymbolResolver(nullptr, &quot;__dl__Z9do_dlopenPKciPK17android_dlextinfoPKv&quot;);</span><br><span class="line">hook_each((unsigned long)loader_dlopen, (void *)dlopen_, (void **)&amp;dlopen_backup);</span><br></pre></td></tr></table></figure>
<p>2.在dl_open里拿到libUE4.so句柄并调用dlsym拿到android_main函数地址,然后Hook android_main.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (strstr(name, &quot;libUE4.so&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        ue4_handle = handle;</span><br><span class="line">        LOGI(&quot;Got libUE4.so handle at %lx&quot;, (long)ue4_handle);</span><br><span class="line">        hook_each((unsigned long)dlsym(ue4_handle, &quot;android_main&quot;), (void *)new_android_main, (void **)&amp;ori_android_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3.在Hook后的android_main里保存android_app.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void new_android_main(struct android_app *app)</span><br><span class="line">&#123;</span><br><span class="line">    // LOGD(&quot;new_android_main&quot;);</span><br><span class="line">    g_App = app; //这个g_App是一个全局变量,保存android_app.</span><br><span class="line">    if (NULL == ori_android_main)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGD(&quot;failed to get original android_main&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    return ori_android_main(app);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h1><p>先将原android_app的onInputEvent保存,然后替换为自己的onInputEvent.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ori_onInputEvent = decltype(ori_onInputEvent)(g_App-&gt;onInputEvent);</span><br><span class="line">LOGD(&quot;ori_onInputEvent:%llx&quot;, (long long)ori_onInputEvent);</span><br><span class="line">g_App-&gt;onInputEvent = onInputEvent;</span><br></pre></td></tr></table></figure>
<p>然后自己的onInputEvent就可以打印输入事件了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int32_t onInputEvent(struct android_app *app, AInputEvent *inputEvent)</span><br><span class="line">&#123;</span><br><span class="line">    LOGD(&quot;onInputEvent&quot;);</span><br><span class="line">    int32_t event_action = AMotionEvent_getAction(inputEvent);</span><br><span class="line">    LOGD(&quot;event_action:%d&quot;, event_action);</span><br><span class="line">    return ori_onInputEvent(app, inputEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/01/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C-%E8%A1%A5%E5%85%85/log.png" alt="log"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/03/24/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/24/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%B8%89/" class="post-title-link" itemprop="url">Android外部imgui绘制(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-24 11:25:43" itemprop="dateCreated datePublished" datetime="2022-03-24T11:25:43+08:00">2022-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-29 18:03:15" itemprop="dateModified" datetime="2022-03-29T18:03:15+08:00">2022-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在获取系统触摸后,剩下的就是解决数据传递和画框子的问题了.</p>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>由于jni是没有root权限的,所以只能由java端运行一个有root权限的进程,然后在root进程里将读取到的数据传回imgui进程.</p>
<h3 id="匿名共享内存"><a href="#匿名共享内存" class="headerlink" title="匿名共享内存"></a>匿名共享内存</h3><p>这是我比较推荐的一个做法,首先用open “&#x2F;dev&#x2F;ashmem”打开匿名共享内存,设置大小,然后mmap函数映射到本地内存.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd =  open(&quot;/dev/ashmem&quot;, O_RDWR);</span><br><span class="line">ioctl(fd, ASHMEM_SET_SIZE, sizeof(AshmemData));</span><br><span class="line">mmap(NULL, sizeof(AshmemData), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>
<p>之后通过 <del>tcp或udp</del> unix socket将fd传给imgui进程里.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_asheme_fd(fd);</span><br></pre></td></tr></table></figure>
<p>imgui进程同样使用mmap来映射匿名共享内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(NULL, sizeof(AshmemData), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>
<p>映射建立后,双方就可以使用匿名共享内存通信了.</p>
<h2 id="共享内存结构"><a href="#共享内存结构" class="headerlink" title="共享内存结构"></a>共享内存结构</h2><p>一般来说,共享内存包括了需要绘制的人物坐标,载具坐标,物品坐标,还需要额外传递一个fps值,这个fps值用来读取内存,画面同步.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct AshmemData&#123;</span><br><span class="line">	PlayerData Player[1000]; //人物数据</span><br><span class="line">	int Playersize; //人物总数</span><br><span class="line">	VehicleData Vehicle[1000]; //载具数据</span><br><span class="line">	int Vehiclesize; //载具数量</span><br><span class="line">	ItemData Item[1000]; // 物品数据</span><br><span class="line">	int Itemsize; // 物品数量</span><br><span class="line">	float fps; //fps,帧率</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>如果是用外部读写的方案,那么可以选择如下方法</p>
<ul>
<li>读取&#x2F;proc&#x2F;pid&#x2F;mem文件.</li>
<li>读取&#x2F;proc&#x2F;pid&#x2F;pagemap文件.</li>
<li>ptrace读内存</li>
<li>syscall(SYS_process_vm_readv, pid, local, 1, remote, 1, 0);</li>
</ul>
<p>如果用Magisk注入的imgui,那就比较简单,直接读取即可.</p>
<p>这里建议有几类数据就开几个线程,比如这里有3类数据(人物,载具,物品),就开三个线程.</p>
<h2 id="数据读取速率与画面刷新速率同步"><a href="#数据读取速率与画面刷新速率同步" class="headerlink" title="数据读取速率与画面刷新速率同步"></a>数据读取速率与画面刷新速率同步</h2><p>屏幕刷新速率通常是固定的,比如120hz的屏幕,每更新1帧的时间大约为0.0083秒,但是你并不能保证读取数据的速率也是0.0083秒.如果不加限制,就会造成性能的浪费,<br>比如屏幕刷新率比数据读取率快,那么就会导致几帧刷新同一画面.<br>如果屏幕刷新率比数据读取率慢,就会导致损失几帧的数据.</p>
<p>通常的做法是计算出每次数据读取的时间.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime(CLOCK_MONOTONIC,&amp;old);</span><br><span class="line">clock_gettime(CLOCK_MONOTONIC,&amp;now);</span><br></pre></td></tr></table></figure>
<p>clock_gettime(CLOCK_MONOTONIC,&amp;now);可以读取到当前的时间.<br>在所有线程开始读取前先调用这个函数,读取数据后调用.然后相减即可得到读取一次数据的时间.</p>
<p>同样的,在imgui渲染线程里同样需要调用这个函数来计算渲染一次所需要的时间</p>
<p>如果谁的时间少,就需要调用usleep函数来等待到fps值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usleep(time)</span><br></pre></td></tr></table></figure>

<h2 id="imgui画框子-文字"><a href="#imgui画框子-文字" class="headerlink" title="imgui画框子,文字"></a>imgui画框子,文字</h2><p>1.imgui画框子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DrawTool::DrawRect(int x, int y, int w, int h, RGBA *color, int thickness)</span><br><span class="line">&#123;</span><br><span class="line">    ImGui::GetOverlayDrawList()-&gt;AddRect(ImVec2(x, y), ImVec2(x + w, y + h), ImGui::ColorConvertFloat4ToU32(ImVec4(color-&gt;R / 255.0, color-&gt;G / 255.0, color-&gt;B / 255.0, color-&gt;A / 255.0)), 0, 0, thickness);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.imgui画文字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DrawTool::DrawNewText(int x, int y, RGBA *color, const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    ImGui::GetOverlayDrawList()-&gt;AddText(ImVec2(x, y), ImGui::ColorConvertFloat4ToU32(ImVec4(color-&gt;R / 255.0, color-&gt;G / 255.0, color-&gt;B / 255.0, color-&gt;A / 255.0)), std::string(str).c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/24/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%B8%89/pic.jpg" alt="pic"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pshocker.github.io/2022/03/23/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.png">
      <meta itemprop="name" content="Shocker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shocker">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C/" class="post-title-link" itemprop="url">Android外部imgui绘制(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 19:11:14" itemprop="dateCreated datePublished" datetime="2022-03-23T19:11:14+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-01 20:20:57" itemprop="dateModified" datetime="2022-04-01T20:20:57+08:00">2022-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Android外部imgui绘制(一)里介绍了怎么实现一个外部imgui,其实还有一种方法,就是在aosp环境下编译一个可执行文件出来,有点类似于<br><a target="_blank" rel="noopener" href="https://github.com/PShocker/Android_executable_draw">可执行文件+skia绘制</a><br>但这个其实很麻烦,需要下载android源码(100多g),然后还要自己编译,最后还得修改代码.所以不太建议这么做.虽然效率可能确实会有提升.</p>
<h2 id="获取触摸"><a href="#获取触摸" class="headerlink" title="获取触摸"></a>获取触摸</h2><p>在绘制imgui后,其实是没有触摸反馈的,原因很简单,在官方示例中,他的入口是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void android_main(struct android_app* app)</span><br></pre></td></tr></table></figure>
<p>这个就很像之前ndk-sample的native-activity了.<br><a target="_blank" rel="noopener" href="https://github.com/android/ndk-samples/tree/main/native-activity">https://github.com/android/ndk-samples/tree/main/native-activity</a><br>,其实可以把这个官方的imgui示例改造成native-activity.</p>
<p>注意看官方示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Poll all events. If the app is not visible, this loop blocks until g_Initialized == true.</span><br><span class="line">        while (ALooper_pollAll(g_Initialized ? 0 : -1, NULL, &amp;out_events, (void**)&amp;out_data) &gt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // Process one event</span><br><span class="line">            if (out_data != NULL)</span><br><span class="line">                out_data-&gt;process(app, out_data);</span><br><span class="line"></span><br><span class="line">            // Exit the app by returning from within the infinite loop</span><br><span class="line">            if (app-&gt;destroyRequested != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // shutdown() should have been called already while processing the</span><br><span class="line">                // app command APP_CMD_TERM_WINDOW. But we play save here</span><br><span class="line">                if (!g_Initialized)</span><br><span class="line">                    shutdown();</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>你就可以发现它是通过调用ALooper_pollAll来获取系统的输入事件,<br>然而在我们的hello-gl2代码里并不能通过ALooper_pollAll来获取输入事件的,<br>那么怎么获取系统输入呢?</p>
<h3 id="ue4-找到android-app并hook-onInputEvent函数"><a href="#ue4-找到android-app并hook-onInputEvent函数" class="headerlink" title="(ue4) 找到android_app并hook onInputEvent函数"></a>(ue4) 找到android_app并hook onInputEvent函数</h3><p>这个方法可以在ue4的游戏中找到,可以把ue4的游戏理解成native-activity,然后找到android_app,在它的onInputEvent里挂钩子,将屏幕输入事件转发给imgui.</p>
<h3 id="双悬浮窗"><a href="#双悬浮窗" class="headerlink" title="双悬浮窗"></a>双悬浮窗</h3><p>比较简单的实现方案,将一个<strong>可点击透明的悬浮窗覆盖在imgui窗口上</strong>,且该悬浮窗随着imgui窗口移动,把对该窗口的输入事件转发到imgui窗口里.</p>
<h3 id="读取系统触摸"><a href="#读取系统触摸" class="headerlink" title="读取系统触摸"></a>读取系统触摸</h3><p>这个方法就是直接读系统输入的方法了,也就是安卓源码是怎么读取屏幕输入的.<br>原理就是读取&#x2F;dev&#x2F;input&#x2F;event?文件,这里的?表示代表屏幕输入文件的数字.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sprintf(dev_name, &quot;/dev/input/event%d&quot;, i);</span><br><span class="line">fd = open(dev_name, O_RDWR);</span><br></pre></td></tr></table></figure>
<p>然后将原始的屏幕输入转成安卓的屏幕输入.最后传给imgui即可.<br>这里可以参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a694543965/article/details/79935086">linux读取触摸屏事件数据</a><br>至于怎么加工原始的输入数据,可以参考安卓源码.</p>
<p>在我的手机上,触摸屏的分辨率是14400x32000.<br>而我的屏幕分辨率是1080x2400.<br>所以需要进一步转换.<br>大致如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (x-xmin) * 手机像素宽 / (xmax-xmin);</span><br><span class="line">y = (y-ymin) * 手机像素高 / (ymax-ymin);</span><br></pre></td></tr></table></figure>
<p>这里xmin,xmax,ymin,ymax可以通过命令拿到.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getevent -p /dev/input/event7</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/23/Android%E5%A4%96%E9%83%A8imgui%E7%BB%98%E5%88%B6-%E4%BA%8C/event.png" alt="event"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0035  : value 0, min 0, max 14399, fuzz 0, flat 0, resolution 0</span><br><span class="line">0036  : value 0, min 0, max 31999, fuzz 0, flat 0, resolution 0</span><br></pre></td></tr></table></figure>

<p>屏幕像素可以通过getRealMetrics获取.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics dm = new DisplayMetrics();</span><br><span class="line">getWindowManager().getDefaultDisplay().getRealMetrics(dm);</span><br><span class="line">int widthPixel = dm.widthPixels;</span><br><span class="line">int heightPixel = dm.heightPixels;</span><br></pre></td></tr></table></figure>
<p>参考<br><a target="_blank" rel="noopener" href="https://www.sohu.com/a/319671175_120058529?qq-pf-to=pcqq.c2c">Android从触碰屏幕开始的事件采集，解析及分发(1)</a>.</p>
<h2 id="屏幕旋转判断"><a href="#屏幕旋转判断" class="headerlink" title="屏幕旋转判断"></a>屏幕旋转判断</h2><p>当屏幕旋转后系统会回调onSurfaceChanged方法<br>在onSurfaceChanged里读取屏幕旋转方向,然后将屏幕方向赋值给native的全局变量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onSurfaceChanged(GL10 gl, int width, int height) &#123;</span><br><span class="line">            set_ImGui_Orientation(MainActivity.windowManager.getDefaultDisplay().getOrientation());</span><br><span class="line">            update_ImGui(width,height);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="屏幕旋转后输入事件的处理"><a href="#屏幕旋转后输入事件的处理" class="headerlink" title="屏幕旋转后输入事件的处理"></a>屏幕旋转后输入事件的处理</h3><p>旋转后,屏幕坐标会旋转,但是读取到的输入坐标不会改变,此时需要将横坐标改为纵坐标,横坐标改为屏幕宽度减去横坐标.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.MousePos = ImVec2(y, physic_w - x);</span><br></pre></td></tr></table></figure>

<h2 id="Android12的改进"><a href="#Android12的改进" class="headerlink" title="Android12的改进"></a>Android12的改进</h2><p>按照官方说明<br><a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#untrusted-touch-events">不受信任的触摸事件被屏蔽</a>.<br>需要做出如下改动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># A specific app</span><br><span class="line">adb shell am compat disable BLOCK_UNTRUSTED_TOUCHES com.example.app</span><br><span class="line"></span><br><span class="line"># All apps</span><br><span class="line"># If you&#x27;d still like to see a Logcat message warning when a touch would be</span><br><span class="line"># blocked, use 1 instead of 0.</span><br><span class="line">adb shell settings put global block_untrusted_touches 0</span><br></pre></td></tr></table></figure>

<p>你可以直接敲下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global block_untrusted_touches 0</span><br></pre></td></tr></table></figure>
<p>之后你的imgui就可以随意的拖动,点击了.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shocker"
      src="/images/test.png">
  <p class="site-author-name" itemprop="name">Shocker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/PShocker" title="https:&#x2F;&#x2F;github.com&#x2F;PShocker" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shocker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
